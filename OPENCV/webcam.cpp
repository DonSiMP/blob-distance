/*
Copyright 2016 Chris Papenfuﬂ

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <stdio.h>
#include <Windows.h>
#include <opencv2/opencv.hpp>
#include <iostream>
#include "kinect_grabber.h"

using namespace std;

void detectAndDraw(cv::Mat& img, cv::CascadeClassifier& cascade,
	cv::CascadeClassifier& nestedCascade,
	double scale, bool tryflip, int frameNum);

string cascadeName;
string nestedCascadeName;
int idx = 0;

bool buildBackground = true;
cv::Mat fgMask, bgMask; //fg mask fg mask generated by MOG2 method
cv::Ptr<cv::BackgroundSubtractor> bgSub; //MOG2 Background subtractor

cv::Ptr<cv::SimpleBlobDetector> blobber;
std::vector<cv::KeyPoint> keypoints;


int main(int, char**) {
	int frameNum = 0;
	double scale;
	bool tryflip;
	cv::CascadeClassifier cascade, nestedCascade;
	//bgSub = cv::createBackgroundSubtractorKNN(90);
	bgSub = cv::createBackgroundSubtractorMOG2(100,16.0,false); //MOG2 approach

	cv::SimpleBlobDetector::Params params = cv::SimpleBlobDetector::Params();
	params.filterByArea = true;
	params.filterByColor = false;
	params.filterByCircularity = false;
	params.filterByConvexity = false;
	params.filterByInertia = false;
	blobber = cv::SimpleBlobDetector::create(params);

	scale = 0.5;
	tryflip = false;

	//open the video stream and make sure it's opened
	KinectGrabber grabber;
	grabber.start();
	cv::Mat * frame = new cv::Mat(grabber.depthHeight, grabber.depthWidth, CV_8UC1);
	grabber.minZ = 0.;// 1000.;
	grabber.maxZ = 0.;// 1500.;

	//frame->resize(grabber.getFrameSize());
	for (;;) {
		try
		{
			if (!grabber.fillFrame(frame)) {
				continue;
			}

			if (buildBackground) {
				bgSub->apply(*frame, fgMask, .8);
			}
			else {
				bgSub->apply(*frame, fgMask, 0.);
			}

			//cv::imwrite("d:\\work\\img.jpg", *frame);
			bgSub->getBackgroundImage(bgMask);
			imshow("Background Mask", bgMask);
			imshow("Foreground Mask", fgMask);
			cv::Mat fgFrame,fgFrameBlobs;
			frame->copyTo(fgFrame, fgMask);
			if (!buildBackground) {
				blobber->detect(fgFrame, keypoints);
				cv::drawKeypoints(fgFrame, keypoints, fgFrameBlobs, cv::Scalar(0, 0, 255), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
				cv::imshow("Foreground with Blobs", fgFrameBlobs);
			}
			cv::imshow("result", *frame);

			imshow("Foreground Frame", fgFrame);
			int c = cv::waitKey(10);
			if (c == 27 || c == 'q' || c == 'Q') {
				break;
			}
			if (c == 'b' || c == 'B') {
				buildBackground = !buildBackground;
				if (buildBackground) {
					bgSub->clear();
				}
			}
		}
		catch (const std::exception&)
		{

		}
	}
	grabber.stop();
}

void detectAndDraw(cv::Mat& img, cv::CascadeClassifier& cascade,
	cv::CascadeClassifier& nestedCascade,
	double scale, bool tryflip, int frameNum)
{
	double t = 0;
	vector<cv::Rect> faces, faces2;
	const static cv::Scalar colors[] =
	{
		cv::Scalar(255,0,0),
		cv::Scalar(255,128,0),
		cv::Scalar(255,255,0),
		cv::Scalar(0,255,0),
		cv::Scalar(0,128,255),
		cv::Scalar(0,255,255),
		cv::Scalar(0,0,255),
		cv::Scalar(255,0,255)
	};
	cv::Mat gray, smallImg;

	img.copyTo(gray, fgMask);
	cvtColor(gray, gray, cv::COLOR_BGR2GRAY);
	double fx = 1 / scale;
	resize(gray, smallImg, cv::Size(), fx, fx, cv::INTER_LINEAR);
	equalizeHist(smallImg, smallImg);

	t = (double)cvGetTickCount();
	if (tryflip)
	{
		flip(smallImg, smallImg, 1);
	}
	t = (double)cvGetTickCount() - t;
	//printf("detection time = %g ms\n", t / ((double)cvGetTickFrequency()*1000.));
	if (faces.size() > 0) {
		cout << "drawing Faces:" + to_string(faces.size()) << std::endl;
	}
	for (size_t i = 0; i < faces.size(); i++)
	{
		cv::Rect r = faces[i];
		cv::Mat smallImgROI;
		vector<cv::Rect> nestedObjects;
		cv::Point center;
		cv::Scalar color = colors[i % 8];
		int radius;

		double aspect_ratio = (double)r.width / r.height;
		if (0.75 < aspect_ratio && aspect_ratio < 1.3)
		{
			center.x = cvRound((r.x + r.width*0.5)*scale);
			center.y = cvRound((r.y + r.height*0.5)*scale);
			radius = cvRound((r.width + r.height)*0.25*scale);
			circle(img, center, radius, color, 3, 8, 0);
		}
		else {
			rectangle(img, cvPoint(cvRound(r.x*scale), cvRound(r.y*scale)),
				cvPoint(cvRound((r.x + r.width - 1)*scale), cvRound((r.y + r.height - 1)*scale)),
				color, 3, 8, 0);
		}
	}
	if (faces.size() > 0) {
		cv::Mat fgFrame;
		img.copyTo(fgFrame, fgMask);
		cv::imwrite("d:\\work\\1\\" + to_string(idx) + "-fgImage.jpg", fgFrame);
		//cv::imwrite("d:\\work\\1\\" + to_string(idx++) + ".jpg", img);

		::SetForegroundWindow((HWND)cvGetWindowHandle("result-gray"));
	}
	cv::imshow("result", img);
	putText(smallImg, to_string(frameNum), cv::Point(15, 15), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255));
	cv::imshow("result-gray", smallImg);
}